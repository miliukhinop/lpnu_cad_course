1. Необхідно побудувати ієрархію класів відповідно схемі наслідування,
наведеній у варіанті завдання.
**Кожен клас повинен містити конструктор
ініціалізації, і функцію show для виведення значень.**
Функція main повинна
ілюструвати ієрархію наслідування.

2. Створити клас для *зберігання бази даних*, вказаної у таблиці з
відповідними полями.

| №   | Предметна область БД | Поля бази даних                     |
| --- | ---                  | ---                                 |
| 4.  | "перелік товарів"    | Назва товару, вага, ціна, кількість |

Утворити похідний клас, залучивши до нього як мінімум
два додаткових поля таким чином, щоб клас набув більшої спеціалізованості.

**Для другого класу використати конструктор, аби він містив усі аргументи,
необхідні для ініціалізації об’єкту похідного класу.**

Створіть необхідні функції, що дозволяють:
* [x] виводити інформацію на екран
* [x] додавати та знищувати записи.

1. У чому суть наслідування в ООП?
2. Який загальний синтаксис опису похідного класу?
3. Який тип доступу буде мати поле зі специфікатором public при захищеному наслідуванні?
4. Який порядок виклику конструкторів та деструкторів при наслідуванні?
5. У чому суть поліморфізму в ООП?
6. Що таке віртуальна функція?
7. Яким чином здійснюється динамічна ідентифікація типів?
8. В яких випадках деструктор має бути віртуальним?

# асоціація

- унарна
- n-арна

## агрегація

Може мінятися

# Композиція

нерозривний зв'язок?

| специфікатор доступу елемента базового касу | тип успадкування |            |            |
| ---                                         | ---              | ---        | ---        |
| public                                      | public           | protected  | private    |
| protected                                   | protected        | protected  | private    |
| private                                     | недоступно       | недоступно | недоступно |

Тобто, поля та методи, які були public у базовому класі, при відкритому
(public) наслідуванні стають також public полями та методами похідного класу.
Аналогічно для інших комбінацій.
Закриті (private) поля та методи базового класу недоступні у похідних
класах. Тому поля та методи, до котрих передбачається доступ у похідних
класах, потрібно оголошувати зі специфікатором protected.

**Ми можемо оголосити конструктор базового класу в класі, що є його спадком (24-27)**

# Слайд 41

```
class Base
{
	private:
	int a;
	protected: int b;
	public:
	int c;
};

class Derived1 : public Base
{...  // A недоступний
	// B - protected член класу Derived1
	// C - public член класу Derived1 };

class Derived2: protected Base
{...  // A недоступний
	// B і C - protected члени класу Derived2 };
class Derived3: private Base
{...  // A недоступний
	// B і C - private члени класу Derived3};
```

* При public члени базового зберігають свою доступність
* При protected члени базового отримують доступність відповідного спеціфікатора
* Приватні члени базового класу завжди недоступні!!!

- Клас-нащадок успадковує всі поля та методи батьківського класу.
- Якщо у батьківському класі поле чи метод приватний, то нащадок
	не має до нього доступу.
- Допускається не тільки успадкування
методів базового класу, але також додавання
нових і перевизначення існуючих методів.
- Якщо ім’я поля (методу) у похідному
і базовому класі співпадають, говорять
про перевизначення або перекриття. Для
зверенення до змінної базового класу використовують `::`

# Конструктори та деструктори базового класу не наслідуються.

Також не наслідуються операція присвоювання та дружні функції.
Похідний клас може мати свої власні конструктори, які будуть викликати
конструктори базового класу. У С++ існує спеціальний синтаксис для передачі
аргументів конструктора похідного класу конструктору базового класу:

```
заголовок_функції: імя_базового_класу (список
аргументів).
```

# В базовому класі деструктор обов’язково має бути віртуальним.
