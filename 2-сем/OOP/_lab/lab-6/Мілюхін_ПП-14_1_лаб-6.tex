%-shell-escape, якщо використовуєте minted
\documentclass[a4paper, 12pt, oneside]{extarticle}
\input{$HOME/Templates/lpnu_doc_templates/settings/preamble.tex}
% якщо домахуються за Times New Roman, то
% використовуєте xelatex і цей файл:
\input{$HOME/Templates/lpnu_doc_templates/settings/font_styles.tex}
\input{$HOME/Templates/lpnu_doc_templates/settings/minted_settings.tex}

\newcommand\Variant{4}
\newcommand\Date{19.05.\the\year}
\newcommand\Discipline{Об'єктно-орієнтоване програмування}
\newcommand\Instructor{Патерега Ю. І.}

\newcommand\Type{\Lab}
\newcommand\Number{6}
\newcommand\Topic{Стандартна бібліотека шаблонів (STL). Smart pointer}

\begin{document}
\Margins

\input{$HOME/Templates/lpnu_doc_templates/parts/header.tex}

Набути уміння та навички розробки та опису програм з використанням
динамічних структур, шаблонів класів та контейнерів. Навчитись застосувати
розумні вказівники бібліотеки STL.

\section*{Індивідуальне завдання}

\subsection*{Завдання 1}

4.  З текстового файлу вилучити дійсні числа у список . Знайти середнє
арифметичне 10 найбільших чисел.

\subsection*{Завдання 2}

4. Описати клас, що реалізує стек. Написати програму, що використовує цей
клас для вирішення проходу по лабіринті. Лабіринт представляється у виді
матриці, що складається з квадратів. Кожен квадрат, або відкритий, або
закритий. Вхід у закритий квадрат заборонений. Якщо квадрат відкритий то вхід
у нього можливий з боку, але не з кута. Кожен квадрат визначається його
координатами в матриці. Після відшукання проходу програма друкує знайдений
шлях у виді координат квадратів.

\section*{Етапи розв'язку}

\begin{enumerate}
		\item Проаналізував завдання.
		\item Дослідив елементи STL, необхідні для викоання поставлених завдань.
		\item Використав розумні вказівники.
\end{enumerate}

\subsection*{Коди програм}

\subsubsection*{завдання 1}

\inputminted{c++}{1.cpp}

\subsubsection*{Результат виконання програми}

\verbatiminput{1.out}

\subsubsection*{завдання 2}

\inputminted{c++}{2.cpp}

\subsubsection*{Результат виконання програми}

\verbatiminput{2.out}

\section*{Висновок}

Я навчився використовувати засоби STL для вирішення
різних проблем.

\section*{Відповіді на контрольні запитання}
\begin{itemize}
	\question Що таке динамічні структури? Опишіть їх.
		\answer Динамічні структури [даних] - це структури даних, які можуть змінювати свій розмір під час виконання програми. Такі структури дозволяють зберігати і змінювати дані залежно від потреб програми.

	\question Як додати новий елемент у список? Приклад.
	\answer Для додавання нового елемента у список потрібно використовувати метод push_back() або insert().

	\question Як видалити елемент з черги? Приклад.
	\answer Для видалення елемента з черги потрібно використати метод pop().

	\question Як додати елемент у стек? Приклад.
	\answer Для додавання елемента у стек можна використати метод push().

	\question Що таке дек? Приклад.
	\answer Дек --- це контейнер, який поєднує функціональність списку та черги. Він дозволяє додавати та видаляти елементи як з початку, так і з кінця контейнера. Наприклад, для додавання елемента до деку можна використати метод push_back() або push_front().
	\question Як включити новий елемент у бінарне дерево? Приклад.
	\answer Для включення нового елемента у бінарне дерево потрібно використати алгоритм пошуку відповідного місця для елемента та додати й
ого в це місце.
	\question Що таке контейнер? Види та їх призначення.
	\answer Контейнер - це об'єкт, який зберігає і управляє колекцією інших об'єктів або значень. Вони дозволяють зберігати, перебирати та змінювати елементи. Залежно від потреби можна використовувати різні типи контейнерів: послідовність (vector, list, deque), асоціативні (map, set, multimap, multiset), контейнери для роботи зі стрічками (string, stringstream), а також інші.
	\question Для чого призначений вектор? Які методи він підтримує?
	\answer Вектор - це послідовність елементів, яка зберігається в зв'язаному списку. Його призначення - це зберігання та доступ до даних в тому ж порядку, в якому вони додавалися. Вектор підтримує методи для додавання, видалення, зміни розміру, отримання розміру, отримання елементів за індексом тощо.

	\question Наведіть два випадки застосування typename.?
	\answer
		\begin{enumerate}
			\item	    Вказівка типу у шаблонних параметрах класу або функції
			\item	Вказівка типу у шаблонних параметрах шаблонного класу або функції
		\end{enumerate}
	\question Як використовується слово export стосовно шаблонів?
	\answer Ключове слово export використовується для зазначення того, що шаблон буде експортовано з бібліотеки і буде доступний для використання в зовнішньому коді. Однак, від версії C++20 ця функція вважається застарілою.

	\question Що таке розумний вказівник?
	\answer Розумний вказівник - це спеціальний об'єкт, який діє як вказівник, але автоматично керує життєтривалістю об'єкта, на який він вказує. Розумні вказівники були створені для полегшення управління пам'яттю в програмах, написаних на C++.

	\question Чим він відрізняється від звичайного?
	\answer Розумний вказівник відрізняється від звичайного вказівника тим, що він автоматично керує життєвим циклом об'єкта, на який він вказує. Це означає, що коли об'єкт, на який вказує розумний вказівник, більше не потрібен, розумний вказівник відповідає за його видалення. Звичайний вказівник не здійснює такого керування і може привести до проблем з пам'яттю, якщо програміст не пам'ятає про видалення об'єкту, на який він вказує.
	\question Порівняйте використані розумні вказівники. <++>
	\answer %Розумні вказівники можна порівняти за типом керування пам'яттю, що вони здійснюють, та за тим, які операції вони підтримують.
std::unique_ptr - забезпечує унікальне володіння об'єктом і не може бути скопійований або переданий власність. Він звільняє пам'ять автоматично, коли вказуваний об'єкт стає непотрібним або при знищенні розумного вказівника.
% std::shared_ptr - забезпечує спільне володіння об'єктом. Об'єкт не звільняється, поки існує хоча б один розумний вказівник, що вказує на нього. Він може бути копійований і переданий власність.
% std::weak_ptr - подібний до std::shared_ptr, але не збільшує лічильник посилань на об'єкт. Він не забезпечує володіння об'єктом, а слугує для перевірки, чи існує об'єкт за допомогою методу lock().

	\question Як можна використовувати розумні вказівники при роботі з контейнерами STL?
	\answer Розумні вказівники можна використовувати для управління пам'яттю, пов'язаною з контейнерами STL. Наприклад, можна використовувати std::unique_ptr для створення вектора.
\end{itemize}

\end{document}
