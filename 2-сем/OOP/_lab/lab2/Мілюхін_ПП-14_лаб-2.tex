\documentclass[a4paper, 12pt, oneside]{extarticle}
%xelatex
%shell-escape
\input{~/Templates/lpnu_doc_templates/settings/preamble.tex}
\input{~/Templates/lpnu_doc_templates/settings/minted_settings.tex}

\newcommand\Variant{4}
\newcommand\Date{24.03.\the\year}
\newcommand\Discipline{Об'єктно-Орієнтоване програмування}
\newcommand\Instructor{Патерега Ю.І.}

\newcommand\Type{\Lab}
\newcommand\Number{2}
\newcommand\Topic{Класи та об’єкти. Композиція класів та об’єктів інших класів}

\begin{document}
\Margins

\input{$HOME/Templates/lpnu_doc_templates/parts/header.tex}

Навчитись розробляти класи для опису об’єктів заданої предметної
області, створювати об’єкти та працювати з ними. Ознайомитись з поняттям
композиції, навчитись розробляти класи, які включають об’єкти інших класів.

\section*{Індивідуальне завдання}
\subsection*{Завдання 1}

Реалізувати вказаний клас.

Клас повинен мати наступні методи:

\begin{enumerate}
	\item конструктор за замовчуванням;
	\item конструктор з параметрами;
	\item функції для зміни кожного з полів класу;
	\item функції для виведення кожного з полів класу.
\end{enumerate}

При зміні полів передбачити перевірку коректності введеної інформації.
У головній програмі створити декілька об’єктів класу, задати  значення,
вивести інформацію на екран. Для класів, у яких полями повинні бути рядки
символів, використайте статичні масиви символів, виділивши достатню кількість
елементів: char name […].

Відділяти інтерфейс класу від реалізації в окремих файлах (.h та .cpp
відповідно).

4. Реалізувати клас Abonent, котрий містить інформацію про клієнта
телефонної компанії: номер договору, прізвище, ім’я, номер телефону, тариф за
хвилину розмови, сума коштів на рахунку.

\subsection*{Завдання 2}

Розробити клас, який буде містити масив об’єктів класу, який було створено у
завданні 1.
Клас повинен  містити наступні поля: статичний масив об’єктів, реальна
кількість елементів в масиві, максимальна кількість елементів в масиві.
Реалізувати функції:

\begin{enumerate}
	\item	додавання нового елемента в масив,
	\item	редагування інформації про об’єкт масиву з вказаним номером,
	\item	видалення об’єкта з масиву,
	\item	виведення на екран інформації про об’єкт масиву з вказаним номером,
	\item	виведення на екран всіх елементів масиву.
\end{enumerate}

У головній програмі створити об’єкт створеного класу, ввести інформацію про
декілька елементів масиву, вивести інформацію на екран.

4. Реалізувати клас Abonents, котрий містить інформацію про абонентів
компанії.
Додатково реалізувати:

\begin{enumerate}
	\item метод сортування абонентів за прізвищем;
	\item метод для виведення на екран списку абонентів, у яких від’ємна сума на рахунку.
\end{enumerate}

%---------------------------------------------
\section*{Етапи розв'язку}

\subsection*{Програмний код до завдання 1}

\subsubsection*{Головний файл}
\inputminted{c++}{abonent/src/1.cpp}

\subsubsection*{Заголовний файл abonent.h}
\inputminted{c++}{abonent/include/abonent.h}

\subsubsection*{Файл abonent.cpp}
\inputminted{c++}{abonent/src/abonent.cpp}
%\verbatiminput{1.cpp}
%\lstinputlisting[frame=single, firstline=1]{./1.cpp}

\subsection*{Результат виконання програми}

\begin{verbatim}
[sasha@honeypot ~d/uni/2-сем/OOP/lab2/abonent/src]$ ./task_1
  ___
 -   -_, ,,                              ,  -_____    _-_ _,,
(  ~/||  ||                             ||    ' | -,     -/  )
(  / ||  ||/|,  /'\\ \\/\\  _-_  \\/\\ =||=  /| |  |`   ~||_<
 \/==||  || || || || || || || \\ || ||  ||   || |==||    || \\
 /_ _||  || |' || || || || ||/   || ||  ||  ~|| |  |,    ,/--||
(  - \\, \\/   \\,/  \\ \\ \\,/  \\ \\  \\,  ~-____,    _--_-'
                                            (          (
Available commands:
set             set value of a field
print           display value of a field
---
Last name:              Hello
Phone number:           12356092
Contract number:        0
Minute rate:            3
Balance:                0
First name:
Last name:              Hello
\end{verbatim}

\subsection*{Програмний код до завдання 2}

\subsubsection*{Головний файл src/main.cpp}
\inputminted{c++}{abonents/src/main.cpp}

\subsubsection*{Заголовний файл src/abonent.h}
\inputminted{c++}{abonents/include/abonent.h}

\subsubsection*{Файл src/abonent.cpp}
\inputminted{c++}{abonents/src/abonent.cpp}

\subsubsection*{Заголовний файл src/abonents.h}
\inputminted{c++}{abonents/include/abonents.h}

\subsubsection*{Файл src/abonents.cpp}
\inputminted{c++}{abonents/src/abonents.cpp}

\subsubsection*{Файл src/Makefile}
\inputminted{make}{abonents/src/Makefile}

\subsubsection*{Файл src/test}
\inputminted{c++}{abonents/src/test}

\subsubsection*{Файл src/snippets/options}
\inputminted{c++}{abonents/src/snippets/options}

\subsubsection*{Файл src/snippets/abonentIndex}
\inputminted{c++}{abonents/src/snippets/abonentIndex}

\subsubsection*{Файл src/snippets/invalidindex}
\inputminted{c++}{abonents/src/snippets/invalidindex}

\subsubsection*{Файл src/snippets/overflow}
\inputminted{c++}{abonents/src/snippets/overflow}

\subsubsection*{Файл banner}
\verbatiminput{abonents/src/banner}

\subsection*{Результат виконання програми}

\verbatiminput{output}

\section*{Висновок}

\subsection*{Відповіді на контрольні запитання}
\begin{itemize}
		\question	{Що таке клас?}

\answer	Клас – це деякий проєкт, з якого створюється об’єкт. У класі закладені
властивості й поведінка майбутнього об’єкта, котрий отримується з класу як із
проєкту.

\question	Що таке об’єкт?

\answer	Об’єкт – це сукупність змінних та функцій, що описує певну сутність.

\question	Для чого потрібен конструктор класу?

\answer	Щоб сформувати екземпляр класу.
В основному він забезпечує валідність початкових значень усіх членів класу.

\question	Для чого потрібен деструктор класу?

\answer	Знищити екземпляр класу в пам'яті, звільнити її для майбутнього використання.

\question	Рівні доступу до полів та методів класу?

\answer	У мові C++ існує 4 рівні доступу:
		\begin{enumerate}
			\item \textit{public}\\
				дає доступ до методів/полів із будь-якої частини програми.
			\item \textit{private}\\
				дає доступ до методів/полів лише в межах їх класу.
			\item \textit{protected}\\
				Доступ у межах класу та його нащадків.
			\item \textit{friend}\\
				надається дозволом від класу, що містить елемент, іншому класу або функції. Має повний доступ до приватних і захищених елементів дружнього класу.
		\end{enumerate}

\question	Що таке композиція? З якою метою використовується?

\answer	Композиція - створення складних об'єктів шляхом комбінування менших об'єктів. Її
використовують з метою забезпечення побудови складніших систем із простих частин та,
відповідно, збільшення гнучкості розробки ПЗ.

\end{itemize}

\end{document}

Клас – це тип даних, а об’єкт – конкретний екземпляр класу, що існує в
пам’яті комп’ютера, змінна відповідного типу.
Клас – це складений тип даних, елементами якого є функції й змінні. До
основи поняття класу покладено той факт, що “над об’єктами можна виконувати
різні операції”. Властивості об’єктів описуються з допомогою полів класів, а дії

Інкапсуляція_об'єднання даних та методів, що їх обробляють (підпрограм), у клас (об'єкт).

Ієрархія класів!! (Дерево об'єктів)

Сутність поліморфізму (дослівно: багато форм) полягає в тому, що об’єкти,
які походять від спільного батька можуть вести себе по-різному в залежності від
ситуації, яка виникає в момент виконання програми. Для досягнення
поліморфізму необхідно мати можливість у класах-нащадках  перевизначати
наявні в батьківському класі методи. Отже, поліморфізм – це можливість
використовувати однакові імена для методів, що входять до різних класів. Тобто,
методи різних класів можуть мати однакові імена, але різний зміст. Це
досягається з допомогою перерозподілу батьківського метода в класів нащадку.
В результаті батько й нащадок поводяться по-різному. Проте звернення до
однойменного методу різних об’єктів виконується однаково.

ШО???

Зменшення кількості публічних членів і методів дозволить мінімізувати
кількість помилок. Бажано, щоб усі члени класу були закритими і тоді буде не
можливо звертатися до членів класу безпосередньо з допомогою оператора «.».

Створюваний шляхом наслідування клас є
похідним (derived class), котрий у свою чергу може виступати в якості базового
класу (based class) для створюваних класів. Якщо імена методів похідного і
базового класів співпадають, то методи похідного класу перезавантажують
методи ба
