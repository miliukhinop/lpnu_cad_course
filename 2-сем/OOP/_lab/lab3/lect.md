
```
void f(int, float);
void f(float, float);
void f(float, int);
// Однотипні аргументи не варто
```

Fraction operator+ (Fraction f1);

operator oppo pooqwep

# Дружні функції


```
class Student
{
private :
	char name [20]; // ім’я студента
	double av_mark; // середній бал
	double ex_mark; // бал за екзамен
// дружня функція
friend void excellent (Student &s);
public :
};
// Ця функція робить відмінником будь-якого студента
void excellent (Student &s)
{
	s.av_mark = 60;
	s.ex_mark = 40;
}
```

1. Функція з модифікатором `friend` --- не член класу.
2. Має такі ж права доступу до всіх членів класу, як і функція-член класу.
3. Не працює `this`
4. Може бути описана в будь-якому місці клсу.
5. Може бути дружньою до кількох класів.

# Вис

> Виклич мені самого себе

```
class Student
{  …
};
int main ()
{
Student st1 (30, 30);
Student st2 (60, 40, "Ivanov");
cout << "Student " << st1.get_mark () << endl;
cout << "Student " << st2.get_exam () << endl;
return 0;
}
```

В даному прикладі функція `get_mark ()` класу одержує
вказівник this, який вказує на екземпляр `st1`, а функція
`get_exam ()` - вказівник this, який вказує на екземпляр `st2`.

# Як перевантажуєш, то ВСІ наявні операції

# Перевантаження присвоєння

1. Слід знати, що за замовченням операція = для
двох екземплярів класу здійснює поелементне
копіювання даних-членів цих екземплярів. Якщо це
саме те, що потрібно для вашого класу, немає
необхідності у перевантаженні операції = .
2. Якщо членом класу є вказівник, то за
замовченням відбуватиметься копіювання
відповідних вказівників, а не об'єктів, на які вони
посилаються (чого, скоріше за все, ви очікуєте при
присвоєнні). В такому разі необхідно коректно
перевантажити операцію = .
3. Використання параметром такої операторної
функції посилання на об'єкт позбавить від
створення та знищення у стеку його копії і
зекономить ресурси.

# Обмеження

1. Перевантажена операція класу повинна мати принаймні
один операнд з типом даного класу – таким чином
забезпечується цілісність операцій зі стандартними
типами даних: ви не можете перевантажити операцію +
для цілих змінних так, щоб вона реалізовувала,
наприклад, віднімання.
2. Перевантажена операція не може змінювати синтаксис
існуючих операцій, наприклад операція % не може бути
унарною. Так само неможливо змінити пріоритети
існуючих операцій.
3. Неможливо створювати нові символи для операцій,
наприклад, x**y неможливо реалізувати як піднесення x
до степеня y.

## Не перевантажуються наступні операції:
sizeof
. (доступ до елементу)
* (операція
вказівник на елемент)
:: (оператор області
видимості)
?: (тернарна операція) та деякі інші,
пов’язані з приведенням та перетворенням типів.

# Зауваження про використання дружніх функцій при перевантаженні операцій.

1. В багатьох випадках не має різниці, яку саме форму
операторної функції (функція-член класу чи дружня
функція) ви використовуєте.
2. Якщо ж ви намагаєтесь перевантажити деяку
операцію, яка буде використовуватись у виразах, де
перший операнд не є екземпляром даного класу
(скажімо, при множенні скаляру на екземпляр класу, що
реалізує вектор або матрицю), то операторна функція
обов'язково  має бути реалізована як дружня.
3. Більшість операцій можуть бути перевантажені як
функції-члени класу, так і з допомогою дружніх функцій.
Проте наступні операції можуть перевантажуватись
лише з допомогою функцій-членів класу: = (присвоєння)
() (оператор виклику функції) [] (оператор індексації)
-> (доступ до членів класу через вказівник).


Операторні функції повинні мати прямий доступ до членів
класу. Отже, необхідно, щоб вони були або членами класу,
або дружніми функціями.

# ВИииис

This --- This – константний вказівник об’єкта на самого себе.  Використовується всередині класу
Його знання про те де він знаходиться в пам’яті.

```
template <typename 11, typename 12>
void Sum(11 a, 12 b);
```
